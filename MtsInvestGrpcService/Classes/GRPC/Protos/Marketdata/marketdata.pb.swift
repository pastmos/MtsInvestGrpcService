// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Ru_Mts_Trading_Marketdata_TimeBox: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case day // = 1
  case week // = 2
  case month // = 3
  case threeMonths // = 4
  case year // = 5
  case threeYears // = 6
  case allTime // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .day
    case 2: self = .week
    case 3: self = .month
    case 4: self = .threeMonths
    case 5: self = .year
    case 6: self = .threeYears
    case 7: self = .allTime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .day: return 1
    case .week: return 2
    case .month: return 3
    case .threeMonths: return 4
    case .year: return 5
    case .threeYears: return 6
    case .allTime: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Mts_Trading_Marketdata_TimeBox: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ru_Mts_Trading_Marketdata_TimeBox] = [
    .unspecified,
    .day,
    .week,
    .month,
    .threeMonths,
    .year,
    .threeYears,
    .allTime,
  ]
}

#endif  // swift(>=4.2)

struct Ru_Mts_Trading_Marketdata_GetIndicatorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var instrumentID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Marketdata_GetIndicatorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `open`: String = String()

  var dayMin: String = String()

  var dayMax: String = String()

  var pe: String = String()

  var yearMax: String = String()

  var yearMin: String = String()

  var allTimeMax: String = String()

  var allTimeMin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Marketdata_GetMDForPeriodRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var instrumentID: String = String()

  var timeBox: Ru_Mts_Trading_Marketdata_TimeBox = .unspecified

  var start: UInt64 = 0

  var end: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Marketdata_MarketDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var instrumentID: String = String()

  var timeBox: Ru_Mts_Trading_Marketdata_TimeBox = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ru_Mts_Trading_Marketdata_MarketDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: UInt64 = 0

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.mts.trading.marketdata"

extension Ru_Mts_Trading_Marketdata_TimeBox: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMEBOX_UNSPECIFIED"),
    1: .same(proto: "DAY"),
    2: .same(proto: "WEEK"),
    3: .same(proto: "MONTH"),
    4: .same(proto: "THREE_MONTHS"),
    5: .same(proto: "YEAR"),
    6: .same(proto: "THREE_YEARS"),
    7: .same(proto: "ALL_TIME"),
  ]
}

extension Ru_Mts_Trading_Marketdata_GetIndicatorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetIndicatorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrumentId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instrumentID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Marketdata_GetIndicatorsRequest, rhs: Ru_Mts_Trading_Marketdata_GetIndicatorsRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Marketdata_GetIndicatorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetIndicatorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "dayMin"),
    3: .same(proto: "dayMax"),
    4: .same(proto: "pe"),
    5: .same(proto: "yearMax"),
    6: .same(proto: "yearMin"),
    7: .same(proto: "allTimeMax"),
    8: .same(proto: "allTimeMin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.`open`)
      case 2: try decoder.decodeSingularStringField(value: &self.dayMin)
      case 3: try decoder.decodeSingularStringField(value: &self.dayMax)
      case 4: try decoder.decodeSingularStringField(value: &self.pe)
      case 5: try decoder.decodeSingularStringField(value: &self.yearMax)
      case 6: try decoder.decodeSingularStringField(value: &self.yearMin)
      case 7: try decoder.decodeSingularStringField(value: &self.allTimeMax)
      case 8: try decoder.decodeSingularStringField(value: &self.allTimeMin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`open`.isEmpty {
      try visitor.visitSingularStringField(value: self.`open`, fieldNumber: 1)
    }
    if !self.dayMin.isEmpty {
      try visitor.visitSingularStringField(value: self.dayMin, fieldNumber: 2)
    }
    if !self.dayMax.isEmpty {
      try visitor.visitSingularStringField(value: self.dayMax, fieldNumber: 3)
    }
    if !self.pe.isEmpty {
      try visitor.visitSingularStringField(value: self.pe, fieldNumber: 4)
    }
    if !self.yearMax.isEmpty {
      try visitor.visitSingularStringField(value: self.yearMax, fieldNumber: 5)
    }
    if !self.yearMin.isEmpty {
      try visitor.visitSingularStringField(value: self.yearMin, fieldNumber: 6)
    }
    if !self.allTimeMax.isEmpty {
      try visitor.visitSingularStringField(value: self.allTimeMax, fieldNumber: 7)
    }
    if !self.allTimeMin.isEmpty {
      try visitor.visitSingularStringField(value: self.allTimeMin, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Marketdata_GetIndicatorsResponse, rhs: Ru_Mts_Trading_Marketdata_GetIndicatorsResponse) -> Bool {
    if lhs.`open` != rhs.`open` {return false}
    if lhs.dayMin != rhs.dayMin {return false}
    if lhs.dayMax != rhs.dayMax {return false}
    if lhs.pe != rhs.pe {return false}
    if lhs.yearMax != rhs.yearMax {return false}
    if lhs.yearMin != rhs.yearMin {return false}
    if lhs.allTimeMax != rhs.allTimeMax {return false}
    if lhs.allTimeMin != rhs.allTimeMin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Marketdata_GetMDForPeriodRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMDForPeriodRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrumentId"),
    2: .same(proto: "timeBox"),
    3: .same(proto: "start"),
    4: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instrumentID)
      case 2: try decoder.decodeSingularEnumField(value: &self.timeBox)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.start)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.end)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if self.timeBox != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeBox, fieldNumber: 2)
    }
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 3)
    }
    if self.end != 0 {
      try visitor.visitSingularUInt64Field(value: self.end, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Marketdata_GetMDForPeriodRequest, rhs: Ru_Mts_Trading_Marketdata_GetMDForPeriodRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.timeBox != rhs.timeBox {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Marketdata_MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrumentId"),
    2: .same(proto: "timeBox"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instrumentID)
      case 2: try decoder.decodeSingularEnumField(value: &self.timeBox)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if self.timeBox != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeBox, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Marketdata_MarketDataRequest, rhs: Ru_Mts_Trading_Marketdata_MarketDataRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.timeBox != rhs.timeBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Mts_Trading_Marketdata_MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startTime)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ru_Mts_Trading_Marketdata_MarketDataResponse, rhs: Ru_Mts_Trading_Marketdata_MarketDataResponse) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
